
> Человек создан для творчества, и я всегда знал, что люблю творить.  
Увы, я обделён талантом художника или музыканта.
Зато умею писать программы.

# Занятие: 1

## Тема: Введение в язык Ruby

### История создания

Первая версия классической реализации появилась в далеком 1995 году..  
Потом долго добирался до Европы и США, так как не было переводов
документации.  
В 2006 получил-таки всеобщее признание.  
А с приходом веб-фреймворка Rails стал ещё более популярным.  
Последняя версия на данный момент Ruby 2.5.1 (MRI) (март 2018).

Официальный сайт: https://www.ruby-lang.org/  
Онлайн-документация: http://www.ruby-doc.org/

<br>

### Какой же он, этот Ruby?
- **динамический**: позволяет определять типы данных в момент
присваивания
значения и осуществлять синтаксический анализ и компиляцию "на лету",
на этапе выполнения программы.  
Динамические языки удобны для быстрой разработки приложений.

- **интерпретируемый**: анализирует и тут же построчно выполняет
(собственно интерпретация) программу по мере поступления её исходного
кода на вход сопрограммы интерпретатора.  
Достоинством такого подхода является мгновенная реакция.  
Недостаток — такой интерпретатор обнаруживает ошибки в тексте
программы только при попытке выполнения команды (или строки) с
ошибкой.

- **сильно типизированный**: несмотря на динамическую типитизацию
у него нет автоматического преведения типов.  
Просто сложить число и строку не получиться
(в отличии, например, от `JavaScript`).

- **объектно-ориентированный**: `Ruby` — полностью
объектно-ориентированный язык. В нём все данные являются объектами,
в отличие от многих других языков, где существуют примитивные типы
(это означает, что и числа, и строки, и даже "ничто" в виде `nil` -
всё это объекты определённого класса). Каждая функция — метод.

- **рефлективный**: что означает, что он может отслеживать и
модифицировать собственную структуру и поведение во время исполнения (определять и переопределять методы и классы во время исполнения).
Это один из видов метапрограммирования.  
На практике означает крайнюю гибкость и изменяемость прямо во время выполнения программы.

- **высокоуровневый**: абстрагирован от реализации самих структур
данных и операций над ними.  
Более понятен человеку и прост в использовании, но в то же время это
сказывается на возможностях языка: прошивки на кофеварки и
операционные системы на нём написать не получится.

- **обладает своим сборщиком мусора**: самостоятельно автоматически
управляет используемой программой памятью.
Специальный процесс, называемый сборщиком мусора, периодически
освобождает память, удаляя объекты, которые уже не будут востребованы программой.

<br>

### Сравнение с другими языками
**Схожесть с Python:**
- наличие интерактивной консоли - `irb`
- наличие системы документации в командной строке - `ri`
- объекты `String` могут хранить многострочные значения
(аналог тройных кавычек в Питоне)
- размер массивов увеличивается автоматически
- объекты динимачески строго типизированы
- всё есть объект и переменные лишь ссылки на объекты
- возможности для документации прямо в тексте программы - `rdoc`
...

**Отличия от Python:**
- объекты строк - изменяемые (в грядущих версиях это изменится)
- наличие констант (переменных, значение которых не планируется
изменять)
- некоторые принятые условия по наименованию (например, классы -
только с большой буквы, локальные переменные - с маленькой)
- только одна реализация списка - массив, и он изменяемый
- двойные кавычки обрабатывают управляющие символы (`\n`, `\t`..)
- весь доступ к атрибутам объектов - через вызов метода, напрямую
нельзя
- скобки в методах, как правило, не обязательны
- отсутствие множественного наследования. Данная функциональность
реализована через примеси модулей
- возможности изменения методов даже стандартной библиотеки
- только `false` и `nil` - ложь. `0`, `0.0` - истина
...

<br>

### Интерпретаторы Ruby. Советы по установке
Существующие реализации:
- **Классический `MRI` - написан на С**
- JRuby - использует виртуальную машину Java
- mruby - облегченная версия для встраивания в другие программы и для
систем с ограниченными ресурсами
И всякая экзотика, которая вам не нужна :smile:

Когда мы будем говорить про `Ruby`, в общем и целом будем подразумевать экосистему: `Ruby` = interpreter + ваш код + `gem`ы, где `gem` - это библиотека. Самое популярное общее хранилищ хостится на https://rubygems.org/.

<br>

### Установка
Несмотря на кроссплатформенность (я ещё не упоминал?), в реальном мире 99% приложений на `Ruby`/`Rails` хостятся на
операционных системах семейства `linux`.
Так что вам придётся подружиться с одной из них :smirk:

Первым шагом проверяем наличие в системе, так как часто он уже
предустановлен:

```bash
$ ruby -v
```

**Далее есть несколько возможных вариантов установки:**
> ! инструкции могут отличаться на других версиях ОС

- **как системный**  
  \+ стабильный и проверенный  
  \+ легко установить  
  \- часто сильно устаревшие версии  
  \- менее гибок (нет возможности сборки со специальными параметрами для своей операционной системы)  
  \- условно только один на всей системе

 ```bash
$ yum install ruby ruby-devel ruby-irb
```

- **из исходных кодов (https://github.com/ruby/ruby)**  
  \+ гибок, можно собрать специально под архитектуру своего компьютера  
  \- "сложен" в установке  
  \- сложнее обновлять версии  
  \- условно только один на всей системе


- **в изолированном окружении, с помощью одной из специальных утилит,
например `rbenv` или `Ruby Version Manager` - `RVM`**  
  \+ возможность использования разных версий на одной машине  
  \+ возможность использования разделенных наборов библиотек для
  каждой из версий или даже проекта  
  \+ легко обновлять, удалять  
  \- при установке возможны конфликты с системными библиотеками
  (решаемо)

Оба решения имеют свои нюансы, `RVM` будет более навороченный и популярнее на данный момент.

**Установка с помощью `RVM`**:

Официальный сайт `RVM` - http://rvm.io/.

```bash
$ yum install сurl
$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
$ \curl -sSL https://get.rvm.io | bash -s stable # исходники тут https://github.com/rvm/rvm , удачи в прочтении :)
$ source ~/.rvm/scripts/rvm # (или переоткрыть сессию терминала)
$ rvm requirements # (доустановит необходимые зависимости под вашу
систему)
```

Проверяем установку:

```bash
$ rvm -v
# rvm 1.29.3 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]
```

Устанавливаем `Ruby v2.5.1`:

```bash
$ rvm install 2.5.1
$ rvm use 2.5.1 --default
$ ruby -v
# ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux]
```

Полезные команды:

```bash
$ rvm list known
$ rvm list / rvm use 2.5.1
$ rvm gemset list / rvm gemset use trololo --default
```

<br>

По-умолчанию `Ruby` устанавливается вместе с несколькими полезными
утилитами: `irb` и `ri`. 

Лично я документацию себе каждый раз не ставлю, но ввиду последних событий в будущем может и понадобится локальная копия :smile:

Отключить можно так:
```bash
$ echo 'gem: --no-rdoc --no-ri' > ~/.gemrc
```

### Работа в `irb`

Интерактивная консоль-песочница: `irb`

Вход:

```bash
$ irb
```

Далее можно проверять любой `Ruby`-код:

```ruby
$ puts "Hello World!"
...
```

Выход:

```bash
$ exit
```

или по **`Ctrl+D`**.

<br>

### Документация `ri`
Поиск по документации в консоли: `ri`

Если ставили `Ruby` через `RVM`, придётся сгренерировать локальную
документацию (как думаете, почему?):

```bash
$ rvm docs generate-ri
```

Вход:

```bash
$ ri
```

Далее можно писать название метода, класса и в ответ получать их
описание (на английском).

```ruby
$ Hash
$ String.split
...
```

Выход: ввести пустую строку или по **`Ctrl+D`**.

<br>

### Где используется `Ruby`?

**tl;dr**
_Там где скорость разработки, читаемость, гибкость, тестируемость и поддержка кода (https://www.ruby-lang.org/en/downloads/branches/) важнее скорости выполнения. Но есть исключения._

Самостоятельно `Ruby` чаще всего используется как скриптовый язык
для написания программ для конфигурации чего-либо, запуска тестов,
разворачивания виртуальных машин в облаке, для расширения
возможностей программ и тд..  
Вместе с веб-фреймворками, такими как `Ruby on Rails`, `Sinatra`,
`Hanami`- уже в качестве полноценных веб-приложений, сайтов и
сервисов.  
Некоторые компании использующие `Ruby` в том или ином виде.
- NASA, NOAA (национальная администрация по океану и атмосфере)
- Motorola
- Discourse - соцсеть-форум
- Amarok - музыкальный плейер
- SketchUp
- Inkscape — скрипты для обработки векторных изображений
- Metasploit
- Chef, Puppet — системы управления конфигурациями
- Redmine — багтрекер
- XChat
- Vagrant & co
- Netmri - ситема автоматизации сетей и управления DNS
- Heroku, Nitrious, Digital Ocean - облачный хостинг
- Epam, Amazon - внутренние проекты (в основном)
- Github - крупнейший портал для разаботчикой и хранения исходных
кодов
- Coub - русскоязычный видео-сервис
- 37signals - система управления проектами
- Shopify - облачная система создания интернет магазинов
- Travis - система тестирования и сборки проектов
...

\+ хостинг провайдеры, мелкий бизнес, сайты, стартапы..  
Также на `Ruby` можно разрабатывать и мобильные приложения, с помощью
оболочек:
- Titanium Studio — среда разработки мобильных приложений на `HMTL5`,
`CSS3`, `Javascript`, `Ruby`, `Rails`, `Python`, `PHP`
- RubyMotion — среда разработки `iOS` и `Android` приложений на `Ruby`

<br>

### Список литературы для самостоятельной работы

- https://ru.wikipedia.org/wiki/Ruby - статья на вики
- https://www.ruby-lang.org/en/documentation/quickstart/ - краткий
экскурс в язык
- https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F -
сравнение с другими языками
- https://pragprog.com/book/ridocker/docker-for-rails-developers - библия
рубистов, в народе именуемая "кирка-книга" :smile:
- https://pragprog.com/book/rails51/agile-web-development-with-rails-5-1 - библия рельсовиков, есть вводные главы по `Ruby`
- есть их переводы на русский, но я полагаю что у вас все OK с English
- https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 -
немного об ООП


## Тема: Синтаксис языка
### Запуск программ:

- Через интерактивную консоль `irb`. Только для проверки чего-либо,
так как данные не сохраняются после выхода данные не сохраняются
после выхода:

```bash
$ irb
```

- Через прямое выполнение интерпретатором:

```ruby
$ ruby -e "variable = a; puts a"
```

- Код в файле, передача файла интерпретатору. Файл находится в той же
папке, где и вызываем:

```bash
$ ruby ./file.rb
```

- Исполняемый `Ruby`-скрипт:  
Код в файле, первой строкой идёт "волшебный" комментарий:
`#!/usr/bin/env ruby`.  Кстати, что такое `env` ?
Добавляем права на запуск и вызываем напрямую.

```bash
$ chmod +x ./file.rb
$ ./file.rb
```

<br>

### Руководство по синтаксису
**Комментарии и вывод:**
В Ruby знаком начала комментария служит `#`. Всё, что между ним и
концом строки пропускается. Пример:

```ruby
puts 2 + 2 # это комментарий
puts "Привет!" # тоже комментарий
```

Многострочные комментарии помещаются между словами `=begin` и `=end`:

```ruby
=begin
Это длинный комментарий
Очень длинный
=end
puts "Привет!"
```

**Названия переменных:**
- начинаются с буквы или `_`
- состоят из латинских букв, цифр или знака подчёркивания
- кроме зарезервированных слов
```ruby
ruby # ok
ruby_tort # ok
ruby_tort666 # ok
_6ruby # ok
___ # и даже это ок
666ruby # а это уже нет
def = 555 # это тоже
```

> Передача происходит по-значению (pass-by-value), но прикол в том, что эти значение - ссылки (reference) . Так называемый "pass-by-object-reference". Нужно иметь ввиду (чтиво https://launchschool.com/blog/references-and-mutability-in-ruby).

**Вывод на кран:**
- `p` – переводит на новую строку, вызывает `#inspect` (выводит в
кавычках реальное содержимое переданного объекта, не обрабатывая
управляющие символы)
- `puts` – переводит на новую строку, вызывает `#to_s` (приводит к
строке, если может, обрабатывает управляющие символы, вывод в
удобочитаемом виде)
- `print` - то же, что и `puts`, но без новой строки
- `printf` – форматированный вывод

Простейшая программа вывода приветствия на экран:

```ruby
puts "Hello, World!"
Hello, World!
 => nil
```

> `;` в конце строки - необязательны
> отступы во вложенных контрукциях: два пробела (не `Tab`)

**Операторы:**
- `=` оператор присваивания
- `!` оператор отрицания. Есть ещё `not`, у него слабее приоритет,
лучше не использовать
- `==` оператор проверки на равенство
- `===` расширенная проверка на равенство или включение,
с приведением типов
(переопределен только на некоторых классах)
- `>`, `<=`, `!=` - операторы сравнения
- `+`, `-`, `/`, `*` - простейшая арифметика
- `**` возведение в степень
- `%` остаток от деления
- `&&` дополнительное условие (и). Есть ещё `and`, у него слабее
приоритет, лучше не использовать
- `||` дополнительное условие (или). Есть ещё `or`, у него слабее
приоритет, лучше не использовать

- `&&`/`and` – выполняют второе условия, только, если первое истина
- `and` слабее `&&`
- `||`/`or` – выполняют второе условия, только, если первое ложно
- `or` слабее `||`

- `!!` приведение к `Boolean`
- `+=` короткая версия инкриментации на заданную величину:

```ruby
a = 1
a += 1 # => 2
a += 2 # => 4
a += 1 # равносильно a = a + 1
```

множественное присваивание:

```ruby
a, b = b, a
```

<br>

#### Прежде чем идти далее, немного поговорим об объектах
Класс - это тип, описывающий устройство объектов  
Объект - некая сущность в памяти, появляющаяся при создании
экземпляра класса (через `#new`)  
Свойства объекта - его атрибуты  

В дальнейшем для удобства чтения будем употреблять термин "экземпляр"
(instance) для объекта и термин "тип" для класса.

Так как каждый описываемый класс имет различные свойства и
выполняемый код, то их нужно где-то хранить. `Ruby` хранит данные
объектах. Поэтому у объектов, описывающих какой-то класс,
так же должен быть свой тип. Отсюда тип (класс) объектов описывающих
сами же классы - есть `Class`.

```ruby
puts 1.class # => Fixnum
puts 1.class.class # => Class
pits 1.class.class.class # => Class
...
```

В данном примере и `1` и `Fixnum` - объекты, но `1` есть экземпляр
типа (класса) `Fixnum`, а `Fixnum` в свою очередь - экземпляр
типа `Class`.

Также все объекты тем или иным образом выведены из класса `Object`
(он в свою очередь от `BasicObject` - "начала всех начал").  
Поэтому даже экземпляры пустого класса имеют минимальный набор методов:

```ruby
class Test; end
test = Test.new
puts test.methods.inspect
```

В данном случае происходит автоматическое наследование `Test` от
`Object`, что равносильно следующему:

```ruby
class Test < Object; end
```

В `Ruby` все данные являются объектами, в отличие от многих других
языков, где существуют примитивные типы (это означает, что и числа,
и строки, и даже "ничто" в виде `nil` - всё это объекты определённого
класса). Каждая функция — метод.

Мы ещё вернёмся подробней к объектной модели `Ruby`, а пока нужно
запомнить, что всё (почти) - есть объект. И пару методов:

вывод типа объекта:

```ruby
1.class # => Fixnum
```

вывод всех методов объекта (без учёта наследования):

```ruby
1.methods # => [:%, :&, ..., :step, :positive?, :negative?, ...]
```

вывод уникального идентификатора объекта:

```ruby
1.object_id # => 3
```

Объекты в парадигме ООП общаются между собой через сообщения,
но иногда это для удобства называют вызовом метода. Пример:

```ruby
'ruby'.capitalize # => Ruby
```

но можно и так:

```ruby
'ruby'.send(:capitalize) # => Ruby
```

Находясь внутри `irb` объектом является специальный объект `main`.
Поэтому каждый метод имеет место, где он определён, даже если
вызывается не явно.
Как `#puts` например, который определён на классe `IO`.

## Тема: Типы данных: `Fixnum(Bignum)`, `Float`, `Boolean`, `String`, `Symbol`, `Array`, `Hash`, `Range`, `Nil`

Слегка устаревшая репрезентация иерархии типов в `Ruby` (2.0):
https://i.stack.imgur.com/1taqB.png

<br>
### Числа

Автоматический переход от типа к типу:  
Fixnum < 2^30  (deprecated, Integer now)
Bignum > 2^30  (deprecated, Integer now)
Complex  
Float  

```ruby
puts 2**3 # => 8 (Fixnum)
puts 2**-3 # => 1 / 8 (Rational) (начиная с Ruby 2)
```

Проблема с округлением у `Float`:

```ruby
0.1 + 0.2 == 0.3 => false 
```

:scream:

Решение

```ruby
(Rational(1,10) + Rational(2,10)).to_f == 0.3 => true
```

Аналогично с болшими числами:

```ruby
12.4 * 1.05 => 13.020000000000001
```

Решение:

```ruby
require 'bigdecimal' => true
(BigDecimal('12.4') * BigDecimal('1.05')).to_f => 13.02
```

*Инструкции для самостоятельной работы:*

```ruby
puts 1 + 1
puts 10 / 3
puts 10.0 / 3
puts 10.class
puts (10 * 99999999999999999999999999999999999).class
puts 123.0.to_i.class
puts 123.to_c
puts 2 ** 3
puts (2 ** -3).class
puts 2 ** 0.5
```

<br>

**Важные методы:**
> Стоит отметить, что каждый возвращает не последнее значение,
а сам вызывающий объект!

`#times` - повторение заданное количество раз
```ruby
3.times { puts '1' }
1
1
1
=> 3
```

`#upto` - повторение до заданного числа, по-возрастанию

```ruby
2.upto(4) { puts '1' } # от 2х до 4х: 2, 3, 4 - 3 раза
1
1
1
=> 2
```

`#downto` - повторение до заданного числа, по-убыванию,
аналогичен `#upto` но вниз
`#step(end, size)` - проход от начального числа до числа = end,
с шагом = size:

```ruby
2.step(6, 2) { puts 1 }
1
1
1
=> 2
```

Важно, что всё они принимают аргументом блок (конструкцию в `{}`),
который умеет аккумулировать текущее значение.  
Сравните с предыдущими вариантами:

```ruby
2.step(6, 2) { |num| puts num }
2 # начинается с 2, как и вызывали
4
6
=> 2
```

```ruby
3.times { |index| puts index }
0 # с нуля начинается
1
2
=> 3
```

```ruby
2.upto(4) { |f| puts f }
2 # начинается с 2, как и вызывали
3
4
=> 2
```

**Методы приведения типов:**
`#to_f` - к `Float`
`#to_c` - к `Сomplex`
`#to_i` - к `Integer`
`#to_s` - к `String` (например полезно когда нужно добавить в конец
строки)

`:**` - возведение в степень:

```ruby
2**3 => 8
```

`#%`- остаток от деления:

```ruby
8 % 5 => 3
```

`#div` - целочисленное
`#abs` - модуль:

```ruby
-3.abs => 3
```

Самостоятельное изучение:
`#between?`  
`#odd?`  
`#even?`  
`#next`  

<br>

### Логические

- true (`TrueClass`)
- false  (`FalseClass`)

Мы уже обсуждали, что в `Ruby` ложь - только `nil` и `false`.

<br>

### Строки
Строки — это произвольной длины наборы символов, которые заключены в
одинарные или двойные кавычки. Примеры строк:

```ruby
"this is a string"  
'this is a string in single quotes'
```

В `Ruby`:
- не ограничены размером
- динамичны (можно расширять, уменьшать..) (будет изменено начиная с 3.0)
- любой объект можно преобразовать в строку (с помощью `#to_s`)
- можно и " (двойные кавычки, позволяют интерполировать значение через
`#{}`, и преобразовывают управляющие символы `\n`, `\t`, ..) и '
(одинарные)
- переменные указывают на объект
- очень богатое API (`Ruby` хорошо работает с текстом и имеет
множество библиотек для этого)

Инструкции для показа:

```ruby
puts "String"
puts 'String'
puts "Time now is #{Time.now}"

puts 'Hello\t\tworld'
puts "Hello\t\tworld"

puts 'Hello\t\tworld'
puts "Hello\t\tworld"
puts "Eat.Sleep.Repeat " * 2
puts "a" < "z"
puts "Z".ord
puts 89.chr

puts "Conca" + "tenation"
puts "Conca" << "tenation"

str1 = "A"
str2 = "B"
puts str1 + " and " + str2 + " are cool letters!"
puts "#{str1} and #{str2} are cool letters!"

puts "2 + 2 = 4".sub("2", "1")
puts "2 + 2 = 4".gsub("2", "1")

puts "ruby".capitalize
puts "RuBy".downcase
puts "RuBy".upcase
puts "ybur".reverse.capitalize


puts "LongString".size
puts "LongString".length

puts "LongString".chop.inspect
puts "LongString\na".chomp.inspect
puts "LongString\n".chomp.inspect
puts "LongString".chomp("ing")
puts "Ruby".swapcase
puts 'LongString'.scan('xx')
puts 'LongString'.scan('St')
puts 'LongString'.count('gn')


string = "abcdefg"
puts string[0]
puts string[100]
puts string[-1]
puts string[2, 3]
puts string[2..4]
puts string[2...4]
puts string.slice(2...4).methods.sort
puts string.index('b')
puts string.include? "abcd"
puts string.insert(4, 'XXX')


puts string.delete 'ae'
puts string.delete 'a-d'
"hello".each_char { |c| puts c }
"hello\nWorld".each_line {|c| puts c}

puts "string".empty?
puts " ".empty?
puts "".empty?

p string.split
puts '-3/2'.to_c

a = "tom"
puts "#{a}, #{a.object_id}"
a = "jerry"
puts "#{a}, #{a.object_id}"

a = "tom"
puts "#{a}, #{a.object_id}"
a.gsub!("tom", "jerry")
puts "#{a}, #{a.object_id}"
```

> Важно: переменные указывают на объект по ссылке, не по значению:

```ruby
girlfriend = "Даша"
goes_on_a_visit = girlfriend
puts girlfriend
=> Даша

goes_on_a_visit[0] = "М" # меняем первую (номер ноль) букву у
переменной-строки
puts girlfriend
=> Маша # WAT?
```

Значение, возвращаемое первой переменной, изменилось потому,
что в `Ruby` переменные содержат лишь ссылку на то, что вы им
присваиваете.  
Сами данные (объект) лежат где-то в другом месте. Ввиду этого
естественно, что при прямом изменении самого объекта, на который
указывает переменная, все другие переменные, указывающие на этот
объект, будут возвращать изменённое значение (также будут изменяться).  
Чтобы `girlfriend` наша осталась `"Даша"`, надо в переменную
занести её копию:

```ruby
girlfriend = "Даша"
goes_on_a_visit = girlfriend.clone
goes_on_a_visit[0] = "М” # Но изменили мы лишь клон. Дома в сохранности сидит настоящая:
puts girlfriend
=> Даша
```

Можно создавать копии объектов ещё методом `#dup`. Разница между ними
будет понятна позже.  
Для безвредного присваивания новых значений переменным их редко
приходится клонировать, ибо большинство методов делают это и так.
Даже если вы просто присвоите переменной новое значение, `Ruby`
создаст объект с новым значением и поместит в (уже существующую)
переменную ссылку на тот объект:

```ruby
goes_on_a_visit = "Аристарх" # Создаётся новый объект, переменная переводится на него
p girlfriend
=> "Даша"
```

**%Q**

Альтернатива строке в двойных кавычках. Полезно, когда в строке
имеются собственные кавычки - вместо экранирования обратным слешем
можно использовать `%Q`:
```ruby
what_tom_said = "Hello"
%Q(Mark said: "Tom said: "#{what_tom_said}"")
=> Mark said: "Tom said: "Hello""
```

Скобки здесь `(...)` могут быть заменены на любой не алфавитный
символ:

```ruby
%Q!Mark said: "Tom said: "#{what_tom_said}""!
%Q[Mark said: "Tom said: "#{what_tom_said}""]
%Q+Mark said: "Tom said: "#{what_tom_said}""+
```

Так же можно использовать:

```ruby
>> %/Mark said: "Tom said: "#{what_tom_said}""/
=> Mark said: "Tom said: "Hello""
```

**%q**
Используется как альтернатива для строки в одинарных кавычках.
Синтаксис похож на `%Q`, но уже без подстановки выражений и
экранирования:

```ruby
%q(Mark said: 'Tom said: '#{what_tom_said} ' ')
=> Mark said: 'Tom said: '#{what_tom_said} ' '
```

**<<HEREDOC’s**

Мы знаем, что Ruby позволяет создавать строковые литералы, которые
занимают несколько физических строк:
```ruby
str = "Welcome to
Ruby!"
```

В результате такого объявления переменная `str` будет хранить
следущую строку: `"Welcome to\nRuby!"`, где `\n` является специальным
символом новой строки.

Существует также следующий стиль (более аккуратный и желаемый) для
создания многострочных строковых литералов:

```ruby
str = <<STR
This is a
multiline
string
STR
```

Здесь, вместо `STR` — идентификатора конца строки может быть
использован любой другой слово, например `error_message`,
`wellcome_message` и так далее.

```ruby
str = <<END
#{"Hello Chuck!"}
END
=> "Hello Chuck!\n"
```

```ruby
str = <<"END"
#{"Hello Chuck!"}
END
=> "Hello Chuck!\n"
```

> обратите внимание на кавычки в которые заключен END

```ruby
str = <<'END'
#{"Hello Chuck!"}
END
#=> "\#{\"Hello Chuck!\"}\n"
```

**Экранирование - через `\`**

```ruby
a = 1 # => 1
b = 2 # => 2
"a + b = \#{a + b}" # => "a + b = \#{a + b}"
"a + b = #{a + b}" # => "a + b = 3"
```

> Пример изменяемости строк по ссылке:

```ruby
f = "f" # => "f"
f.object_id # => 14461460
f << "1" # => "f1"
f.object_id # => 14461460

f = 'last' # => "last"
f.object_id # => 13609880
```

<br>

### Символы

- храняться всё время выполнения программы, независимо от контекста
- уникальны (один и тот же объект) (показать имена методов)
- не изменяемы
- это не `String`, хоть чем-то и похожи
- `GarbageCollector` научится с ними работать только c версии 2.2. Теперь все ок.

> Вывод всех проинициализированных символов

```ruby
Symbol.all_symbols
```

- `#to_s` - данный метод используется для преобразования объекта в
строку, если быть совсем точным, то объект преобразовываться в другой
тип не может, просто создается другой, аналогичный
объект — строкового типа:

```ruby
:symbol.to_s #=> "symbol"
```

- `#to_sym` — метод предназначен для получения соответствующего
строке символа:

```ruby
"string".to_sym #=> :string
```

Еще один малоизвестный способ преобразовать строку в символ — просто
поставить перед строкой двоеточие, данный способ, вполне может
заменить метод `to_s` в тех случаях, когда используется
непосредственно для строки, а не для переменной ссылающейся на нее:

```ruby
symbol = "string".to_sym #=> :string
symbol.object_id #=> 54088
symbol2 = :"string" #=> :string
symbol2.object_id # => 54088
```

### Домашнее задание: 1
#### Теория:
- прочесть заметки лекции ещё раз, два, три...
- изучить следующие ссылки:
  - информация о числах https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5_%D0%BE_%D1%87%D0%B8%D1%81%D0%BB%D0%B0%D1%85
  - информация о строках https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5_%D0%BE_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D1%85

- Осмотреться в документации:
	- https://ruby-doc.org/core-2.5.0/Integer.html
  - http://ruby-doc.org/core-2.5.0/Float.html
  - http://www.ruby-doc.org/core-2.5.0/String.html
  - http://www.ruby-doc.org/core-2.5.0/Symbol.html
- составить список вопросов
- выделить одну интересную и запомнившуюся особенность/метод/факт связанный с `Ruby`


#### Практика:

### `Ruby`: руководство по стилю оформления, код скриптов должен с большего им соответствовать
- https://github.com/arbox/ruby-style-guide/blob/master/README-ruRU.md -
по-русски
- https://github.com/styleguide/ruby
- https://github.com/airbnb/ruby

- установить `Ruby 2.5.1` через `RVM`
- создать новый `gemset mtn`, сделать его дефолтным при заходе в shell
- установить в нем библиотеки-гемы `bundler`, `pry`, `sqlite3`
- __\*\*\*__ поиграть в игру-курс
https://tryruby.org/levels/1/challenges/0

1. на вход (читать "в переменной") подаётся текст вида:

```bash
10.6.246.103 - - [23/Apr/2018:20:30:39 +0300] "POST /grid/2/messages HTTP/1.1" 200 48 0.0498
10.6.246.101 - - [23/Apr/2018:20:30:42 +0300] "POST /grid/2/event HTTP/1.1" 200 - 0.2277
2018-04-23 20:30:42: SSL error, peer: 10.6.246.101, peer cert: , #<Puma::MiniSSL::SSLError: System error: Undefined error: 0 - 0>
10.6.246.101 - - [23/Apr/2018:20:29:39 +0300] "POST /grid/2/messages HTTP/1.1" 200 48 0.0290
```

Вывести на экран:
- полный текст строки с ошибкой (наличие подстроки "error" в любом регистре)
- для каждой строки (без ошибки) вывести соответствующую ей комбинацию вида: "datetime from: ip_address to: endpoint_path(в большом регистре)"
  например, для примера выше первым выводом будет: "23/Apr/2018:20:30:39 +0300 FROM: 10.6.246.103 TO: /GRID/2/MESSAGES"

2. на вход (читать "в переменной") подаётся текст вида:

```bash
2018-04-23 17:17:49.7 ubuntu-xenial[14319] Debug - Calling core with action: event
2018-04-23 17:17:49.7 ubuntu-xenial[14319] Debug - connecting to: 10.6.246.101
2018-04-23 17:17:49.8 ubuntu-xenial[14319] Debug - docker event processed
2018-04-23 17:18:19.5 ubuntu-xenial[14319] Debug - monitoring grid communication health
2018-04-23 17:18:38.8 ubuntu-xenial[14319] Debug - Calling core with action: messages
2018-04-23 17:18:38.8 ubuntu-xenial[14319] Debug - connecting to: 10.6.246.101
2018-04-23 17:18:59.8 ubuntu-xenial[14319] Debug - inside docker_handle_event
```

Вывести на экран длительность действия в СЕКУНДАХ между событиями, произошедшими в момент "Calling core with action: <%whatever%)".
Между ними может сколько угодно других событий.
Для данного примера вывод будет: (2018-04-23 17:18:38.8 - 2018-04-23 17:17:49.7) = (38.8 + 10.3) = "49.1" <- только это число

3. Дана произвольная строка, в которой есть буквы, цифры, кони, лоси..
Вывести на экран сумму всех цифр из данной строки. (вещественные числа, типа 3.14 рассматриваются как 3 числа)

Домашку присылать по адресу: `aliaksandr_buhayeu@epam.com` с темой письма: `MTN_APR_18:L_1:NAME_SURNAME`.
У меня фильтр на письма, кто не справится с темой - домашку не проверю :smile:

> Домашка - это **ОДИН** исполняемый `Ruby`-скрипт, в котором решения задачек разделены каким-нибудь коментарием / описанием задачи.

> Называйте ваш скрипт: `name_surname_l1.rb`.  
Спасибо!

##### На этом всё, жду вас на следующем занятии!
